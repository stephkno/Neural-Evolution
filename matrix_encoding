#!/usr/local/anaconda3/envs/experiments/bin/python3
import numpy
import random

class Network():
    def __init__(self, inputs, outputs, binary):
        super(Network, self).__init__()
        self.inputs = inputs
        self.outputs = outputs

        mat_size = inputs+outputs
        self.size = mat_size
        self.genome = numpy.zeros((mat_size, mat_size))
        self.nodes = numpy.zeros(mat_size)
        self.recurrence = numpy.zeros(mat_size)
        self.activation = numpy.tanh
        self.fitness = 0.0
        self.connections = 0
        self.binary = binary
        self.neuron_decay = 0.9
        self.recurrent_decay = 0.0

    def get_genome(self):
        genome = self.genome.flatten()
        genome = {"size": [self.size], "genome": genome, "fitness": 0, "generation": 0}
        return genome

    def softmax(self, x):
        return numpy.exp(x) / sum(numpy.exp(x))
    def sigmoid(self, x):
        return 1 / (1 + numpy.exp(-x))

    def get_weight(self):
        if self.binary:
            #return binary weight
            return random.choice([-1,1])
        else:
            #return continuous weight
            return random.random()*2-1

    #def prune(self):
    #    for i,x in enumerate(self.genome):
    #        if i >= self.inputs and i < self.size-self.outputs:
    #            if

    def eval(self, x):

        #clear node vectors
        self.nodes = self.nodes * self.neuron_decay
        self.nodes[-self.outputs:] *= 0.0

        recurr_mask = numpy.zeros(self.size)
        for i in range(self.inputs, (self.size-self.outputs)):
            recurr_mask[i] = 1.0

        #activate and add previous iteration's recurrence vector
        self.nodes += self.activation(self.recurrence)
        self.recurrence = (self.recurrence * recurr_mask) * self.recurrent_decay

        x = numpy.array(x)
        x = x.flatten()

        #fill input nodes
        for i, input in enumerate(x):
            self.nodes[i] = input

        #evaluate each node
        for i, node in enumerate(self.nodes):
            vec = self.activation(node)
            row = (self.genome[i] * vec) # multiply node input by weights

            #split row into two parts
            recurrent_row = row[:i]
            node_row = row[i:]

            #cat zeros to end
            a = numpy.zeros_like(recurrent_row)
            b = numpy.zeros_like(node_row)

            recurrent_row = numpy.concatenate((recurrent_row, b))
            node_row = numpy.concatenate((a, node_row))

            #add values to output nodes
            self.recurrence += recurrent_row

            self.nodes += node_row
           # #if i > self.size - self.outputs:
            #    print(self.genome[i][-2:])

        out = self.nodes[-self.outputs:]
        return self.activation(out)

    def add_node(self, x):
        for _ in range(x):
            #insert new node into vectors
            self.nodes = numpy.insert(self.nodes, self.inputs, 0.0, axis=0)
            self.recurrence = numpy.insert(self.recurrence, self.inputs, 0.0, axis=0)
            #insert row and column into genome
            self.genome = numpy.insert(self.genome, self.inputs, 0.0, axis=0)
            self.genome = numpy.insert(self.genome, self.inputs, 0.0, axis=1)
            self.size += 1

    def add_gene(self, inp):
        for _ in range(inp):

            inputs = []
            outputs = []
            hiddens = []

            for i in range(self.inputs):
                inputs.append(i)
            for i in range((self.inputs), (self.size-self.outputs)):
                hiddens.append(i)
            for i in range((self.size-self.outputs), self.size):
                outputs.append(i)

            #choice 1: connect input to hidden
            #choice 2 connect hidden to output
            #choice 3 connect hidden to hidden

            choice = random.choice(range(2))

            if choice == 0:
                x = random.choice(inputs)  # choose in or out node
                y = random.choice(hiddens)  # choose hidden node
            if choice == 1:
                x = random.choice(hiddens)  # choose in or out node
                y = random.choice(outputs)  # choose hidden node
            #if choice == 2:
           #     x = random.choice(hiddens)  # choose in or out node
            #    y = random.choice(hiddens)  # choose hidden node

            r = random.random() * 2 - 1
            if self.binary:
                if r > 0.0:
                    r = 1.0
                elif r <= 0.0:
                    r = -1.0

            self.genome[x][y] = r
            if self.genome[x][y] > 1.0: self.genome[x][y] = 1.0
            if self.genome[x][y] < -1.0: self.genome[x][y] = -1.0
            self.connections += 1

    def remove_gene(self, x):
        for _ in range(x):
            x = random.choice(range(len(self.genome)))
            choice = []
            for i, c in enumerate(self.genome[x]):
                if c != 0.0:
                    choice.append(i)

            if len(choice) == 0: break
            y = random.choice(choice)

            if x <= self.size - self.outputs:
                self.genome[x][y] = 0.0
                self.connections -= 1

    def mutate_gene(self, x):
        for i in range(x):
            x = random.choice(range(len(self.genome)))
            choice = []
            for i, c in enumerate(self.genome[x]):
                if c != 0.0:
                    choice.append(i)

            if len(choice) == 0: break
            y = random.choice(choice)

            r = (random.random() * 2 - 1)

            if self.binary:
                if r > 0.0: r = 1.0
                elif r <= 0.0: r = -1.0

            d = r
            self.genome[x][y] += d

            if self.genome[x][y] > 1.0: self.genome[x][y] = 1.0
            if self.genome[x][y] < -1.0: self.genome[x][y] = -1.0

    def add_output_connections(self):
        #for i in range(self.inputs):
        #    self.genome[i][i] = 0.0
        #for i in range(self.outputs):
        ##    for z in range(self.inputs, (self.size-self.outputs)):
        #        self.genome[z][-(i+1)] = numpy.random.random()
        #    for z in range(self.outputs):
        #        self.genome[-(i+1)][(self.size-self.outputs)+z] = 0.0
        pass
